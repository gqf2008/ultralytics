// YOLOv8/v5 后处理模块
// 基于 Ultralytics 官方实现

use anyhow::Result;
use image::{DynamicImage, ImageBuffer};
use ndarray::{s, Array, Axis, IxDyn};

use crate::{non_max_suppression, Bbox, Embedding, Point2, DetectionResult, YOLOTask};

/// YOLOv8 配置
pub struct YOLOv8Config {
    pub task: YOLOTask,
    pub nc: usize,        // 类别数
    pub nk: usize,        // 关键点数 (姿态任务)
    pub nm: usize,        // mask 系数数 (分割任务)
    pub conf: f32,        // 置信度阈值
    pub kconf: f32,       // 关键点置信度阈值
    pub iou: f32,         // IOU 阈值
    pub width: usize,     // 模型输入宽度
    pub height: usize,    // 模型输入高度
}

impl YOLOv8Config {
    pub fn new(
        task: YOLOTask,
        nc: usize,
        width: usize,
        height: usize,
        conf: f32,
        iou: f32,
    ) -> Self {
        Self {
            task,
            nc,
            nk: 17,  // 默认 COCO 关键点数
            nm: 32,  // 默认 mask 系数数
            conf,
            kconf: 0.55,
            iou,
            width,
            height,
        }
    }
}

/// YOLOv8 后处理器
pub struct YOLOv8Postprocessor {
    config: YOLOv8Config,
}

impl YOLOv8Postprocessor {
    pub fn new(config: YOLOv8Config) -> Self {
        Self { config }
    }

    /// 计算缩放后的尺寸
    fn scale_wh(&self, w0: f32, h0: f32, w1: f32, h1: f32) -> (f32, f32, f32) {
        let r = (w1 / w0).min(h1 / h0);
        (r, (w0 * r).round(), (h0 * r).round())
    }

    /// 后处理主函数
    pub fn postprocess(
        &self,
        xs: Vec<Array<f32, IxDyn>>,
        xs0: &[DynamicImage],
    ) -> Result<Vec<DetectionResult>> {
        // 分类任务
        if let YOLOTask::Classify = self.config.task {
            let mut ys = Vec::new();
            let preds = &xs[0];
            for batch in preds.axis_iter(Axis(0)) {
                ys.push(DetectionResult::new(
                    Some(Embedding::new(batch.into_owned())),
                    None,
                    None,
                    None,
                ));
            }
            return Ok(ys);
        }

        // 检测/分割/姿态任务
        const CXYWH_OFFSET: usize = 4; // cxcywh
        const KPT_STEP: usize = 3; // xyconf
        
        let preds = &xs[0];
        let protos = if xs.len() > 1 { Some(&xs[1]) } else { None };
        
        let mut ys = Vec::new();
        
        for (idx, anchor) in preds.axis_iter(Axis(0)).enumerate() {
            // [bs, 4 + nc + nm, anchors]
            let width_original = xs0[idx].width() as f32;
            let height_original = xs0[idx].height() as f32;
            let ratio = (self.config.width as f32 / width_original)
                .min(self.config.height as f32 / height_original);

            let mut data: Vec<(Bbox, Option<Vec<Point2>>, Option<Vec<f32>>)> = Vec::new();
            
            for pred in anchor.axis_iter(Axis(1)) {
                // 提取 bbox
                let bbox = pred.slice(s![0..CXYWH_OFFSET]);
                let clss = pred.slice(s![CXYWH_OFFSET..CXYWH_OFFSET + self.config.nc]);
                
                // 提取关键点 (姿态任务)
                let kpts = if let YOLOTask::Pose = self.config.task {
                    Some(pred.slice(s![pred.len() - KPT_STEP * self.config.nk..]))
                } else {
                    None
                };
                
                // 提取 mask 系数 (分割任务)
                let coefs = if let YOLOTask::Segment = self.config.task {
                    Some(pred.slice(s![pred.len() - self.config.nm..]).to_vec())
                } else {
                    None
                };

                // 找到最大置信度的类别
                let (id, &confidence) = clss
                    .into_iter()
                    .enumerate()
                    .reduce(|max, x| if x.1 > max.1 { x } else { max })
                    .unwrap();

                // 置信度过滤
                if confidence < self.config.conf {
                    continue;
                }

                // bbox 缩放到原图
                let cx = bbox[0] / ratio;
                let cy = bbox[1] / ratio;
                let w = bbox[2] / ratio;
                let h = bbox[3] / ratio;
                let x = cx - w / 2.;
                let y = cy - h / 2.;
                
                let y_bbox = Bbox::new(
                    x.max(0.0f32).min(width_original),
                    y.max(0.0f32).min(height_original),
                    w,
                    h,
                    id,
                    confidence,
                );

                // 关键点缩放
                let y_kpts = if let Some(kpts) = kpts {
                    let mut kpts_ = Vec::new();
                    for i in 0..self.config.nk {
                        let kx = kpts[KPT_STEP * i] / ratio;
                        let ky = kpts[KPT_STEP * i + 1] / ratio;
                        let kconf = kpts[KPT_STEP * i + 2];
                        
                        if kconf < self.config.kconf {
                            kpts_.push(Point2::default());
                        } else {
                            kpts_.push(Point2::new_with_conf(
                                kx.max(0.0f32).min(width_original),
                                ky.max(0.0f32).min(height_original),
                                kconf,
                            ));
                        }
                    }
                    Some(kpts_)
                } else {
                    None
                };

                data.push((y_bbox, y_kpts, coefs));
            }

            // NMS
            non_max_suppression(&mut data, self.config.iou);

            // 解码结果
            let mut y_bboxes: Vec<Bbox> = Vec::new();
            let mut y_kpts: Vec<Vec<Point2>> = Vec::new();
            let mut y_masks: Vec<Vec<u8>> = Vec::new();
            
            for elem in data.into_iter() {
                if let Some(kpts) = elem.1 {
                    y_kpts.push(kpts);
                }

                // 解码 mask (分割任务)
                if let Some(coefs) = elem.2 {
                    let proto = protos.unwrap().slice(s![idx, .., .., ..]);
                    let (nm, nh, nw) = proto.dim();

                    // coefs * proto -> mask
                    let coefs = Array::from_shape_vec((1, nm), coefs)?;
                    let proto_owned = proto.to_owned();
                    let proto_reshaped = proto_owned.to_shape((nm, nh * nw))?;
                    let mask_dot = coefs.dot(&proto_reshaped);
                    let mask = mask_dot.to_shape((nh, nw, 1))?;

                    // 构建 mask 图像
                    let mask_im: ImageBuffer<image::Luma<_>, Vec<f32>> =
                        ImageBuffer::from_raw(
                            nw as u32,
                            nh as u32,
                            mask.to_owned().into_raw_vec_and_offset().0,
                        )
                        .expect("Failed to create mask image");
                    
                    let mut mask_im = image::DynamicImage::from(mask_im);

                    // 缩放 mask 到原图尺寸
                    let (_, w_mask, h_mask) = self.scale_wh(
                        width_original,
                        height_original,
                        nw as f32,
                        nh as f32,
                    );
                    
                    let mask_cropped = mask_im.crop(0, 0, w_mask as u32, h_mask as u32);
                    let mask_original = mask_cropped.resize_exact(
                        width_original as u32,
                        height_original as u32,
                        match self.config.task {
                            YOLOTask::Segment => image::imageops::FilterType::CatmullRom,
                            _ => image::imageops::FilterType::Triangle,
                        },
                    );

                    // 用 bbox 裁剪 mask
                    let mut mask_original_cropped = mask_original.into_luma8();
                    for y in 0..height_original as usize {
                        for x in 0..width_original as usize {
                            if x < elem.0.xmin() as usize
                                || x > elem.0.xmax() as usize
                                || y < elem.0.ymin() as usize
                                || y > elem.0.ymax() as usize
                            {
                                mask_original_cropped.put_pixel(
                                    x as u32,
                                    y as u32,
                                    image::Luma([0u8]),
                                );
                            }
                        }
                    }
                    y_masks.push(mask_original_cropped.into_raw());
                }
                
                y_bboxes.push(elem.0);
            }

            // 保存结果
            let y = DetectionResult {
                probs: None,
                bboxes: if !y_bboxes.is_empty() {
                    Some(y_bboxes)
                } else {
                    None
                },
                keypoints: if !y_kpts.is_empty() {
                    Some(y_kpts)
                } else {
                    None
                },
                masks: if !y_masks.is_empty() {
                    Some(y_masks)
                } else {
                    None
                },
            };
            ys.push(y);
        }

        Ok(ys)
    }
}
